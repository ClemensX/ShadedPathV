#version 460
#extension GL_EXT_mesh_shader : enable
#extension GL_EXT_debug_printf : enable

#include "pbr_mesh_common.glsl"

// Bindings must match your descriptor set layout
layout(std430, binding = 2) buffer MeshletBuffer {
    uvec4 packedMeshlets[];
} meshletDescs;

// Define the maximum number of meshlets to dispatch
// (You may want to pass this as a push constant or specialization constant)
#define NUM_MESHLETS 128

layout(local_size_x = 32) in; // 32 threads per workgroup

void check_inputs() {
    uvec4 uv = meshletDescs.packedMeshlets[0];
    //debugPrintfEXT("meshlet uvec4[0] %f %f %f %f\n", uv.x, uv.y, uv.z, uv.w);
    MeshletDesc meshlet = unpackMeshletDesc(uv);
    uint indexBufferOffset = meshlet.indexBufferOffset;
    debugPrintfEXT("meshlet indexBufferOffset %d\n", indexBufferOffset);
}

void main() {
    //check_inputs();
    uint meshletIndex = gl_GlobalInvocationID.x;
//    if (meshletIndex >= NUM_MESHLETS) {
//        debugPrintfEXT("task shader meshlet index out-of-range: %d\n", meshletIndex);
//        return;
//    }
//
    //debugPrintfEXT("task shader still thereX\n");
    // Read and unpack meshlet
    //uvec4 packed = meshletDescs.packedMeshlets[meshletIndex];
    //MeshletDesc meshlet = unpackMeshletDesc(packed);

    // Example: Dispatch a mesh shader workgroup for this meshlet
    // (You would typically call EmitMeshTasksEXT here)
    // For demonstration, emit one mesh task per meshlet
    //EmitMeshTasksEXT(meshletIndex, 1, 1); // (groupX, groupY, groupZ)
    //debugPrintfEXT("task shader b4 emit\n");
    EmitMeshTasksEXT(1, 1, 1); // (groupX, groupY, groupZ)
    //debugPrintfEXT("task shader emitted\n");
}