#version 460
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_mesh_shader : enable
#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "common_cpp_shader.h"
#include "shadermaterial.glsl"
#include "pbr_mesh_common.glsl"

// default set (0) bindings:
// binding 0: global UBO (MVP)
// binding 1: per-model UBO (PBR, model matrix, bounding box, meshlet count, material, flags)
// mesh storage buffer (for all meshes) is bindless!!
// set 1 bindings:
// binding 0: global textures

layout(local_size_x = 1) in; // not using the usual 32 threads per workgroup, but only 1 as we implement object culling and LOD object selection here

taskPayloadSharedEXT TaskPayload payload;

GPUMeshIndexBuffer gpuIndices = GPUMeshIndexBuffer(pushConstants.meshStorageBufferAddress + 0);
GPUMeshInfoBuffer gpuInfos = GPUMeshInfoBuffer(pushConstants.baseAddressInfos);

//uint meshIndex = 9;
//MeshletDescs meshletDescs = MeshletDescs(pushConstants.meshStorageBufferAddress + gpuInfos.info[meshIndex].meshletOffset);
//GlobalIndexBuffer globalIndexBuffer = GlobalIndexBuffer(pushConstants.meshStorageBufferAddress + gpuInfos.info[meshIndex].globalIndexOffset);
//PrimitiveIndexBuffer primitiveIndexBuffer = PrimitiveIndexBuffer(pushConstants.meshStorageBufferAddress + gpuInfos.info[meshIndex].localIndexOffset);
//VertexBuffer vertices = VertexBuffer(pushConstants.meshStorageBufferAddress + gpuInfos.info[meshIndex].vertexOffset);

void logPayload() {
    debugPrintfEXT("TaskPayload: meshletIndex %u, meshIndex %u\n", payload.meshletIndex, payload.meshIndex);
}

void check_inputs() {
    GPUMeshIndex gi = gpuIndices.index[0];
    //debugPrintfEXT("TASK SHADER GPUIndex 0 0: %llx\n", test.gpuMeshInfoBaseAddress[0]);//gi.gpuMeshInfoBaseAddress[0]);
    debugPrintfEXT("TASK SHADER GPUIndex 0 0: %x\n", gi.gpuMeshInfoIndex[0]);
    //GPUMeshInfoBuffer gpuInfos = GPUMeshInfoBuffer(pushConstants.meshStorageBufferAddress + gi.gpuMeshInfoBaseAddress[0]);
    debugPrintfEXT("TASK SHADER GPUInfo 0: meshlet offset: %llx\n", gpuInfos.info[0].meshletOffset);

    uint meshIndex = 0;
    VertexBuffer vertices = VertexBuffer(pushConstants.meshStorageBufferAddress + gpuInfos.info[meshIndex].vertexOffset);
    PBRVertex v = vertices.vertex[0];
    //debugPrintfEXT("TASK SHADER: vertex[0]: %f %f %f\n", v.position.x, v.position.y, v.position.z);
    v = vertices.vertex[1];
    //debugPrintfEXT("TASK SHADER: vertex[1]: %f %f %f\n", v.position.x, v.position.y, v.position.z);
    //debugPrintfEXT("TASK SHADER: you have %d meshlets in this mesh!\n", model_ubo.meshletsCount);
    //debugPrintfEXT("TASK SHADER: mesh buffer base address %llx\n", model_ubo.GPUMeshStorageBaseAddress);
    //debugPrintfEXT("TASK SHADER: vertex offset %d\n", model_ubo.vertexOffset);

//    vec4 v = ubo.model[0];
//    //debugPrintfEXT("model %f %f %f %f\n", v.x, v.y, v.z, v.w);
//    v = ubo.view[0];
//    //debugPrintfEXT("view %f %f %f %f\n", v.x, v.y, v.z, v.w);
//    v = ubo.proj[0];
//    //debugPrintfEXT("proj %f %f %f %f\n", v.x, v.y, v.z, v.w);
//    v = ubo.baseColor;
//    //debugPrintfEXT("col %f %f %f %f\n", v.x, v.y, v.z, v.w);
//    //vec3 cp = ubo.camPos;
//    //debugPrintfEXT("cam %f %f %f\n", ubo.camPos.x, ubo.camPos.y, ubo.camPos.z);
//
    PrimitiveIndexBuffer primitiveIndexBuffer = PrimitiveIndexBuffer(pushConstants.meshStorageBufferAddress + gpuInfos.info[meshIndex].localIndexOffset);
    uint index = 3;
    uint byteValue0 = (primitiveIndexBuffer.primitiveIndices[index / 4] >> ((index % 4) * 8)) & 0xFFu;
    index = 4;
    uint byteValue1 = (primitiveIndexBuffer.primitiveIndices[index / 4] >> ((index % 4) * 8)) & 0xFFu;
    index = 5;
    uint byteValue2 = (primitiveIndexBuffer.primitiveIndices[index / 4] >> ((index % 4) * 8)) & 0xFFu;
    //debugPrintfEXT("TASK SHADER byte values: %d %d %d\n", byteValue0, byteValue1, byteValue2);

    //uint globalIndex0 = globalIndexBuffer.index[4];
    //debugPrintfEXT("TASK SHADER global index[0..4] %d %d %d %d %d\n", globalIndexBuffer.index[0],globalIndexBuffer.index[1],globalIndexBuffer.index[2],globalIndexBuffer.index[3],globalIndexBuffer.index[4]);

    MeshletDescs meshletDescs = MeshletDescs(pushConstants.meshStorageBufferAddress + gpuInfos.info[meshIndex].meshletOffset);
    uvec4 uv = meshletDescs.packedMeshlets[1];
    //debugPrintfEXT("meshlet uvec4[0] %f %f %f %f\n", uv.x, uv.y, uv.z, uv.w);
    MeshletDesc meshlet = unpackMeshletDesc(uv);
    uint indexBufferOffset = meshlet.indexBufferOffset;
    //debugPrintfEXT("TASK SHADER meshlet indexBufferOffset %d\n", indexBufferOffset);

    PBRVertex vert = vertices.vertex[1];
    //debugPrintfEXT("TASK SHADER vertex[1] position %f %f %f\n", vert.position.x, vert.position.y, vert.position.z);

	vec3 w = ubo.camPos;
	//debugPrintfEXT("cam pos %f %f %f\n", w.x, w.y, w.z);

    vec4 v2 = model_ubo.model[0];
    //debugPrintfEXT("model_ubo %f %f %f %f\n", v.x, v.y, v.z, v.w);

    BoundingBox bb = model_ubo.boundingBox;
    //debugPrintfEXT("bb min %f %f %f\n", bb.min.x, bb.min.y, bb.min.z);
    //debugPrintfEXT("bb max %f %f %f\n", bb.max.x, bb.max.y, bb.max.z);


    uint meshletsCount = model_ubo.meshletsCount;
    //uint meshletIndex = gl_GlobalInvocationID.x;
    uint meshletIndex = gl_WorkGroupID.x;
    uint localIndex = gl_LocalInvocationID.x;
    //if (meshletIndex > 2506)
    //debugPrintfEXT("TASK SHADER WrkGrop.x %d localIndex %d meshletsCount %d\n", meshletIndex, localIndex, meshletsCount);

	ShaderMaterial material = model_ubo.material;
	uint u0 = material.texCoordSets.baseColor;
	uint u1 = material.texCoordSets.normal;
	uint u2 = material.texCoordSets.occlusion;
	//debugPrintfEXT("task coord sets base %d normal %d occlusion %d\n", u0, u1, u2);
    //debugPrintfEXT("task coord base %f %f %f %f spec %f %f %f %f\n", material.baseColorFactor.x, material.baseColorFactor.y, material.baseColorFactor.z, material.baseColorFactor.w, material.specularFactor.x, material.specularFactor.y, material.specularFactor.z, material.specularFactor.w);
    //debugPrintfEXT("task shader material workflow %f base set %d\n", material.workflow, material.baseColorTextureSet);

    uint flags = model_ubo.flags;
    bool isRenderingDisabled = (flags & MODEL_RENDER_FLAG_DISABLE) != 0;
	//debugPrintfEXT("TASK SHADER: rendering disabled %d\n", isRenderingDisabled);
   // debugPrintfEXT("TASK SHADER: vertex offset %d\n", model_ubo.vertexOffset);


}

float fixed_lod[10] = { 0, 1, 5, 10, 15, 25, 30, 50, 70, 150 };


// Calculates the LOD index based on the given lod distances and current distance.
// lod: array of LOD distances (lod[1]..lod[9]), lod[0] is unused.
// distance: current camera-to-object distance, scaled to 1m width!!
// Returns: LOD index in range 0..9 (0 = closest, 9 = farthest).
uint calculateLODIndex(float distance) {
    // LOD 0 is always used for distance < lod[1]
    for (int i = 9; i >= 1; --i) {
        if (distance >= fixed_lod[i]) {
            return i;
        }
    }
    return 0;
}

void main() {
    //check_inputs();

    //debugPrintfEXT("TASK SHADER: model flags: %d\n", model_ubo.flags);
    //debugPrintfEXT("TASK SHADER PUUUUSH: : %llx\n", pushConstants.meshStorageBufferAddress);
    //debugPrintfEXT("TASK SHADER: model_ubo.GPUMeshStorageBaseAddress %llx\n", model_ubo.GPUMeshStorageBaseAddress);
    if (model_ubo.meshNumber == 0) {
        //debugPrintfEXT("TASK SHADER: model_ubo.meshNumber is ZERO! This is invalid!\n");
    }
    bool isRenderingDisabled = (model_ubo.flags & MODEL_RENDER_FLAG_DISABLE) != 0;
    bool isGpuLodEnabled = (model_ubo.flags & MODEL_RENDER_FLAG_GPU_LOD) != 0;

    mat4 model = model_ubo.model;
    mat4 view = ubo.view;
    mat4 proj = ubo.proj;
    mat4 mvp = proj * view * model;

    if (isRenderingDisabled) {
        // signal to mesh shader that this object is culled/disabled.
        payload.meshletIndex = PAYLOAD_CULLED;
        payload.mvp = mvp;
        //debugPrintfEXT("TASK SHADER: RENDERING DISABLED for object %d, payload %u\n", model_ubo.objectNum, payload.meshletIndexX);
        // Emit a single dummy mesh task so the pipeline/driver receives a mesh task invocation.
        // The mesh shader must test for payload.meshletIndex == PAYLOAD_CULLED and return immediately.
        // debugPrintfEXT("TASK[%u:%u] object %u DISABLED -> payload.meshletIndex=%u (returning)\n", gl_WorkGroupID.x, gl_LocalInvocationID.x, model_ubo.objectNum, payload.meshletIndexX);
        EmitMeshTasksEXT(1, 1, 1);
        return;
    }

    bool isOutside = isOutsideView(model_ubo.boundingBox, mvp);
    if (isOutside) {
        // Don't emit mesh tasks for this object ï¿½ but emit one dummy so drivers stay happy.
        BoundingBox bb = model_ubo.boundingBox;
        //debugPrintfEXT("TASK SHADER: OUTSIDE bb min %f %f %f\n", bb.min.x, bb.min.y, bb.min.z);
        payload.meshletIndex = PAYLOAD_CULLED;
        payload.mvp = mvp;
        EmitMeshTasksEXT(1, 1, 1);
        return;
    }
    // Visible: emit actual mesh tasks for meshlets
    if (gl_WorkGroupID.x > 10962)
    debugPrintfEXT("TASK SHADER: gl_WorkGroupID. x %d y %d z %d\n", gl_WorkGroupID.x, gl_WorkGroupID.y, gl_WorkGroupID.z);
    // Now each workgroup handles exactly one meshlet
    uint meshletIndex = gl_WorkGroupID.x;  // Use workgroup ID instead of global invocation ID
    
    // Check if this workgroup's meshlet index is valid
    //    if (meshletIndex >= model_ubo.meshletsCount) {
    //        return; // Skip invalid meshlet indices
    //    }
  
    if (!isRenderingDisabled && !isOutside) {
        // LOD selection:
        uint meshIndex = model_ubo.meshNumber; // default to exact mesh specified in model_ubo (for non-LOD rendering)
        //debugPrintfEXT("TASK SHADER: model_ubo flags: %u\n", model_ubo.flags);
        //debugPrintfEXT("TASK SHADER: isGpuLodEnabled: %d\n", isGpuLodEnabled ? 1 : 0);
        if (isGpuLodEnabled) {
            // scale to have 1m width for LOD 0 object:
            BoundingBox box = model_ubo.boundingBox;
            float width = box.max.x - box.min.x;
            float scale = 1.0f / width;
            vec3 camPos = ubo.camPos;
            vec3 objPos = model_ubo.objPos;
            objPos.y = 0.0f;
            float dist = length(camPos - objPos);
            float distScaled = dist * scale;
            //debugPrintfEXT("TASK SHADER: object %u dist %f scaled %f\n", model_ubo.objectNum, dist, distScaled);

            uint lodLevel = calculateLODIndex(dist);
            //debugPrintfEXT("TASK SHADER: object %u dist %f scaled %f ==> level: %u\n", model_ubo.objectNum, dist, distScaled, lodLevel);
            meshIndex = model_ubo.meshNumber + lodLevel; // we rely on proper selection of LOD 0 mesh number in app code!!
        }
        // meshIndex is the LOD mesh we want to render, determine its meshlet count:
        uint meshletsCount = gpuInfos.info[meshIndex].meshletCount;
        //debugPrintfEXT("TASK SHADER: render mesh index %u with meshletsCount %u\n", meshIndex, meshletsCount);
        // Emit selectedCount mesh shader workgroups.
        // We emit one mesh workgroup at a time so each gets a distinct payload.meshletIndex.
        payload.mvp = mvp;
        payload.meshIndex = meshIndex;
        payload.meshletIndex = 0; // never used
        //debugPrintfEXT("TASK SHADER: mesh loop mi %u meshletIndex %u\n", mi, payload.meshletIndex);
        //logPayload();
        // Optionally print once for debugging:
        // if (mi == 0u) debugPrintfEXT("TASK: object %u LOD %u selectedCount %u dist %f\n", model_ubo.objectNum, lod, selectedCount, dist);
        EmitMeshTasksEXT(meshletsCount, 1, 1);
        //debugPrintfEXT("TASK[%u:%u] object %u emitting meshlet %u, is disabled == %u\n", gl_WorkGroupID.x, gl_LocalInvocationID.x, model_ubo.objectNum, meshletIndex, isRenderingDisabled ? 1 : 0);
    }
}

