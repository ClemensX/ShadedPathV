#version 460
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_mesh_shader : enable

#include "shadermaterial.glsl"
#include "pbr_mesh_common.glsl"

// Meshlet descriptor buffer (binding = 2)
layout(std430, binding = 2) buffer MeshletBuffer {
    uvec4 packedMeshlets[];
} meshletDescs;

// local primitive index buffer:
layout(std430, binding = 3) buffer PrimitiveIndexBuffer {
    uint primitiveIndices[];
} primitiveIndexBuffer;

// global index buffer:
layout(std430, binding = 4) buffer GlobalIndexBuffer {
    uint index[];
} globalIndexBuffer;

// vertex storage buffer (NOT vertex buffer)
layout(std430, binding = 5) buffer VertexStorageBuffer {
    PBRVertex vertex[];
} vertices;

// Define the maximum number of meshlets to dispatch
// (You may want to pass this as a push constant or specialization constant)
#define NUM_MESHLETS 128

layout(local_size_x = 32) in; // 32 threads per workgroup

void check_inputs() {
//    vec4 v = ubo.model[0];
//    //debugPrintfEXT("model %f %f %f %f\n", v.x, v.y, v.z, v.w);
//    v = ubo.view[0];
//    //debugPrintfEXT("view %f %f %f %f\n", v.x, v.y, v.z, v.w);
//    v = ubo.proj[0];
//    //debugPrintfEXT("proj %f %f %f %f\n", v.x, v.y, v.z, v.w);
//    v = ubo.baseColor;
//    //debugPrintfEXT("col %f %f %f %f\n", v.x, v.y, v.z, v.w);
//    //vec3 cp = ubo.camPos;
//    //debugPrintfEXT("cam %f %f %f\n", ubo.camPos.x, ubo.camPos.y, ubo.camPos.z);
//
    uint index = 3;
    uint byteValue0 = (primitiveIndexBuffer.primitiveIndices[index / 4] >> ((index % 4) * 8)) & 0xFFu;
    index = 4;
    uint byteValue1 = (primitiveIndexBuffer.primitiveIndices[index / 4] >> ((index % 4) * 8)) & 0xFFu;
    index = 5;
    uint byteValue2 = (primitiveIndexBuffer.primitiveIndices[index / 4] >> ((index % 4) * 8)) & 0xFFu;
    //debugPrintfEXT("TASK SHADER byte values: %d %d %d\n", byteValue0, byteValue1, byteValue2);

    uint globalIndex = globalIndexBuffer.index[4];
    //debugPrintfEXT("TASK SHADER global index[4] %d\n", globalIndex);

    uvec4 uv = meshletDescs.packedMeshlets[0];
    //debugPrintfEXT("meshlet uvec4[0] %f %f %f %f\n", uv.x, uv.y, uv.z, uv.w);
    MeshletDesc meshlet = unpackMeshletDesc(uv);
    uint indexBufferOffset = meshlet.indexBufferOffset;
    //debugPrintfEXT("TASK SHADER meshlet indexBufferOffset %d\n", indexBufferOffset);

    PBRVertex vert = vertices.vertex[0];
    //debugPrintfEXT("TASK SHADER vertex[0] position %f %f %f\n", vert.position.x, vert.position.y, vert.position.z);

	vec3 w = ubo.camPos;
	//debugPrintfEXT("cam pos %f %f %f\n", w.x, w.y, w.z);

    vec4 v = model_ubo.model[0];
    //debugPrintfEXT("model_ubo %f %f %f %f\n", v.x, v.y, v.z, v.w);

    uint meshletsCount = model_ubo.meshletsCount;
    debugPrintfEXT("TASK SHADER meshletsCount %d\n", meshletsCount);
}

void main() {
    //meshletDescs.packedMeshlets[0] = uvec4(-1, -1, -1, -1);
    check_inputs();
    uint meshletIndex = gl_GlobalInvocationID.x;
//    if (meshletIndex >= NUM_MESHLETS) {
//        debugPrintfEXT("task shader meshlet index out-of-range: %d\n", meshletIndex);
//        return;
//    }
//
    //debugPrintfEXT("task shader still thereX\n");
    // Read and unpack meshlet
    //uvec4 packed = meshletDescs.packedMeshlets[meshletIndex];
    //MeshletDesc meshlet = unpackMeshletDesc(packed);

    // Example: Dispatch a mesh shader workgroup for this meshlet
    // (You would typically call EmitMeshTasksEXT here)
    // For demonstration, emit one mesh task per meshlet
    //EmitMeshTasksEXT(meshletIndex, 1, 1); // (groupX, groupY, groupZ)
    //debugPrintfEXT("task shader b4 emit\n");
    EmitMeshTasksEXT(1, 1, 1); // (groupX, groupY, groupZ)
    //debugPrintfEXT("task shader emitted\n");
}