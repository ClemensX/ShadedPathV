#version 460
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_mesh_shader : enable
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "common_cpp_shader.h"
#include "shadermaterial.glsl"
#include "pbr_mesh_common.glsl"

// default set (0) bindings:
// binding 0: global UBO (MVP)
// binding 1: per-model UBO (PBR, model matrix, bounding box, meshlet count, material, flags)
// mesh storage buffer (for all meshes) is bindless!!
// set 1 bindings:
// binding 0: global textures

layout(buffer_reference, std430) buffer VertexBuffer {
    PBRVertex vertex[];
};

layout(buffer_reference, std430) buffer MeshletDescs {
    uvec4 packedMeshlets[];
};

// local primitive index buffer:
layout(buffer_reference, std430) buffer PrimitiveIndexBuffer {
    uint primitiveIndices[];
};

// global index buffer:
layout(buffer_reference, std430) buffer GlobalIndexBuffer {
    uint index[];
};

layout(local_size_x = 1) in; // not using the usual 32 threads per workgroup, but only 1 as we implement object culling and LOD object selection here

taskPayloadSharedEXT TaskPayload payload;

MeshletDescs meshletDescs = MeshletDescs(model_ubo.GPUMeshStorageBaseAddress + model_ubo.meshletOffset);
GlobalIndexBuffer globalIndexBuffer = GlobalIndexBuffer(model_ubo.GPUMeshStorageBaseAddress + model_ubo.globalIndexOffset);
PrimitiveIndexBuffer primitiveIndexBuffer = PrimitiveIndexBuffer(model_ubo.GPUMeshStorageBaseAddress + model_ubo.localIndexOffset);
VertexBuffer vertices = VertexBuffer(model_ubo.GPUMeshStorageBaseAddress + model_ubo.vertexOffset);

void check_inputs() {
    PBRVertex v = vertices.vertex[0];
    debugPrintfEXT("TASK SHADER: vertex[0]: %f %f %f\n", v.position.x, v.position.y, v.position.z);
    v = vertices.vertex[1];
    debugPrintfEXT("TASK SHADER: vertex[1]: %f %f %f\n", v.position.x, v.position.y, v.position.z);
    debugPrintfEXT("TASK SHADER: you have %d meshlets in this mesh!\n", model_ubo.meshletsCount);
    //debugPrintfEXT("TASK SHADER: mesh buffer base address %d\n", model_ubo.GPUMeshStorageBaseAddress);
    //debugPrintfEXT("TASK SHADER: vertex offset %d\n", model_ubo.vertexOffset);

//    vec4 v = ubo.model[0];
//    //debugPrintfEXT("model %f %f %f %f\n", v.x, v.y, v.z, v.w);
//    v = ubo.view[0];
//    //debugPrintfEXT("view %f %f %f %f\n", v.x, v.y, v.z, v.w);
//    v = ubo.proj[0];
//    //debugPrintfEXT("proj %f %f %f %f\n", v.x, v.y, v.z, v.w);
//    v = ubo.baseColor;
//    //debugPrintfEXT("col %f %f %f %f\n", v.x, v.y, v.z, v.w);
//    //vec3 cp = ubo.camPos;
//    //debugPrintfEXT("cam %f %f %f\n", ubo.camPos.x, ubo.camPos.y, ubo.camPos.z);
//
    uint index = 3;
    uint byteValue0 = (primitiveIndexBuffer.primitiveIndices[index / 4] >> ((index % 4) * 8)) & 0xFFu;
    index = 4;
    uint byteValue1 = (primitiveIndexBuffer.primitiveIndices[index / 4] >> ((index % 4) * 8)) & 0xFFu;
    index = 5;
    uint byteValue2 = (primitiveIndexBuffer.primitiveIndices[index / 4] >> ((index % 4) * 8)) & 0xFFu;
    debugPrintfEXT("TASK SHADER byte values: %d %d %d\n", byteValue0, byteValue1, byteValue2);

    //uint globalIndex0 = globalIndexBuffer.index[4];
    debugPrintfEXT("TASK SHADER global index[0..4] %d %d %d %d %d\n", globalIndexBuffer.index[0],globalIndexBuffer.index[1],globalIndexBuffer.index[2],globalIndexBuffer.index[3],globalIndexBuffer.index[4]);

    uvec4 uv = meshletDescs.packedMeshlets[1];
    //debugPrintfEXT("meshlet uvec4[0] %f %f %f %f\n", uv.x, uv.y, uv.z, uv.w);
    MeshletDesc meshlet = unpackMeshletDesc(uv);
    uint indexBufferOffset = meshlet.indexBufferOffset;
    debugPrintfEXT("TASK SHADER meshlet indexBufferOffset %d\n", indexBufferOffset);

    PBRVertex vert = vertices.vertex[1];
    //debugPrintfEXT("TASK SHADER vertex[1] position %f %f %f\n", vert.position.x, vert.position.y, vert.position.z);

	vec3 w = ubo.camPos;
	//debugPrintfEXT("cam pos %f %f %f\n", w.x, w.y, w.z);

    vec4 v2 = model_ubo.model[0];
    //debugPrintfEXT("model_ubo %f %f %f %f\n", v.x, v.y, v.z, v.w);

    BoundingBox bb = model_ubo.boundingBox;
    //debugPrintfEXT("bb min %f %f %f\n", bb.min.x, bb.min.y, bb.min.z);
    //debugPrintfEXT("bb max %f %f %f\n", bb.max.x, bb.max.y, bb.max.z);


    uint meshletsCount = model_ubo.meshletsCount;
    //uint meshletIndex = gl_GlobalInvocationID.x;
    uint meshletIndex = gl_WorkGroupID.x;
    uint localIndex = gl_LocalInvocationID.x;
    //if (meshletIndex > 2506)
    //debugPrintfEXT("TASK SHADER WrkGrop.x %d localIndex %d meshletsCount %d\n", meshletIndex, localIndex, meshletsCount);

	ShaderMaterial material = model_ubo.material;
	uint u0 = material.texCoordSets.baseColor;
	uint u1 = material.texCoordSets.normal;
	uint u2 = material.texCoordSets.occlusion;
	//debugPrintfEXT("task coord sets base %d normal %d occlusion %d\n", u0, u1, u2);
    //debugPrintfEXT("task coord base %f %f %f %f spec %f %f %f %f\n", material.baseColorFactor.x, material.baseColorFactor.y, material.baseColorFactor.z, material.baseColorFactor.w, material.specularFactor.x, material.specularFactor.y, material.specularFactor.z, material.specularFactor.w);
    //debugPrintfEXT("task shader material workflow %f base set %d\n", material.workflow, material.baseColorTextureSet);

    uint flags = model_ubo.flags;
    bool isRenderingDisabled = (flags & MODEL_RENDER_FLAG_DISABLE) != 0;
	//debugPrintfEXT("TASK SHADER: rendering disabled %d\n", isRenderingDisabled);
   // debugPrintfEXT("TASK SHADER: vertex offset %d\n", model_ubo.vertexOffset);
}

void main() {
    //check_inputs();

    //debugPrintfEXT("TASK SHADER: model flags: %d\n", model_ubo.flags);
    bool isRenderingDisabled = (model_ubo.flags & MODEL_RENDER_FLAG_DISABLE) != 0;

    mat4 model = model_ubo.model;
    mat4 view = ubo.view;
    mat4 proj = ubo.proj;
    mat4 mvp = proj * view * model;

    // sentinel value used to signal culled/disabled from task -> mesh shader
    const uint PAYLOAD_CULLED = 0xFFFFFFFFu;

    if (isRenderingDisabled) {
        //debugPrintfEXT("WARNING: RENDERING DISABLED for this object\n");
        // signal to mesh shader that this object is culled/disabled.
        payload.meshletIndex = PAYLOAD_CULLED;
        payload.mvp = mvp;
        // Emit a single dummy mesh task so the pipeline/driver receives a mesh task invocation.
        // The mesh shader must test for payload.meshletIndex == PAYLOAD_CULLED and return immediately.
        EmitMeshTasksEXT(1, 1, 1);
        return;
    }

    bool isOutside = isOutsideView(model_ubo.boundingBox, mvp);
    if (isOutside) {
        // Don't emit mesh tasks for this object ï¿½ but emit one dummy so drivers stay happy.
        BoundingBox bb = model_ubo.boundingBox;
        //debugPrintfEXT("WARNING: OUTSIDE bb min %f %f %f\n", bb.min.x, bb.min.y, bb.min.z);
        payload.meshletIndex = PAYLOAD_CULLED;
        payload.mvp = mvp;
        EmitMeshTasksEXT(1, 1, 1);
        return;
    }
    // Visible: emit actual mesh tasks for meshlets
    // Now each workgroup handles exactly one meshlet
    uint meshletIndex = gl_WorkGroupID.x;  // Use workgroup ID instead of global invocation ID
    
    // Check if this workgroup's meshlet index is valid
    if (meshletIndex >= model_ubo.meshletsCount) {
        return; // Skip invalid meshlet indices
    }
    
    payload.meshletIndex = meshletIndex;
    payload.mvp = mvp;
    debugPrintfEXT("TASK SHADER: processing meshlet %d of %d\n", meshletIndex, model_ubo.meshletsCount);
    // Each task shader workgroup emits exactly one mesh shader workgroup
    EmitMeshTasksEXT(1, 1, 1);
}

