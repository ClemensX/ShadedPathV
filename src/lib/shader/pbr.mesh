#version 460
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_mesh_shader : enable
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "common_cpp_shader.h"
#include "shadermaterial.glsl"
#include "pbr_mesh_common.glsl"
#include "debug_colors.glsl"

layout(buffer_reference, std430) buffer VertexBuffer {
    PBRVertex vertex[];
};

layout(buffer_reference, std430) buffer MeshletDescs {
    uvec4 packedMeshlets[];
};

// local primitive index buffer:
layout(buffer_reference, std430) buffer PrimitiveIndexBuffer {
    uint primitiveIndices[];
};

// global index buffer:
layout(buffer_reference, std430) buffer GlobalIndexBuffer {
    uint index[];
};


taskPayloadSharedEXT TaskPayload payload;

// Output: up to 256 vertices and 512 primitives per meshlet (adjust as needed)
layout(local_size_x = 1) in;
layout(max_vertices = GLEXT_MESHLET_VERTEX_COUNT, max_primitives = GLEXT_MESHLET_PRIMITIVE_COUNT) out;
layout(triangles) out;

layout(location = 0) out PBRVertexOutFlat outVertFlat[];
layout(location = 1) out PBRVertexOut outVert[];

MeshletDescs meshletDescs = MeshletDescs(model_ubo.GPUMeshStorageBaseAddress + model_ubo.meshletOffset);
GlobalIndexBuffer globalIndexBuffer = GlobalIndexBuffer(model_ubo.GPUMeshStorageBaseAddress + model_ubo.globalIndexOffset);
PrimitiveIndexBuffer primitiveIndexBuffer = PrimitiveIndexBuffer(model_ubo.GPUMeshStorageBaseAddress + model_ubo.localIndexOffset);
VertexBuffer vertices = VertexBuffer(model_ubo.GPUMeshStorageBaseAddress + model_ubo.vertexOffset);

void unpackAABB(uint pHigh, uint pLow, vec3 objectMin, vec3 objectMax) {
    debugPrintfEXT("uint64 aabb value: 0x %08x %08x\n", pHigh, pLow);
}

void check_inputs() {
    //uint maxPrim = gl_MaxMeshOutputPrimitivesEXT;
    //uint maxVert = gl_MaxMeshOutputVerticesEXT;
    uint meshletIndex = gl_WorkGroupID.x;
    if (meshletIndex != 185) return;
    uvec4 uv = meshletDescs.packedMeshlets[meshletIndex];
    //debugPrintfEXT("meshlet uvec4[0] %f %f %f %f\n", uv.x, uv.y, uv.z, uv.w);
    MeshletDesc meshlet = unpackMeshletDesc(uv);
    uint indexBufferOffset = meshlet.indexBufferOffset;
    //debugPrintfEXT("MESH SHADER meshlet index %d and indexBufferOffset %d\n", meshletIndex, indexBufferOffset);

    mat4 mvp = payload.mvp;
    //debugPrintfEXT("MESH SHADER mvp %f %f %f %f\n", mvp[0][0], mvp[1][1], mvp[2][2], mvp[3][3]);

    //debugPrintfEXT("MESH SHADER object render mode: flags == %d\n", model_ubo.flags);
    ShaderMaterial material = model_ubo.material;
    //debugPrintfEXT("mesh shader material workflow %f base set %d\n", material.workflow, material.baseColorTextureSet);
}

// Main mesh shader entry
void main()
{
    //check_inputs();

    // check for culled objects:
    if (payload.meshletIndex == 0xFFFFFFFFu) {
        //debugPrintfEXT("MESH SHADER: object culled\n");
        SetMeshOutputsEXT(0, 0);
        return;
    }

    // Get meshlet index from task shader or workgroup
    uint meshletIndex = gl_WorkGroupID.x;
    meshletIndex = payload.meshletIndex;
    //if (meshletIndex < 1) debugPrintfEXT("MESH SHADER meshletIndex %d\n", meshletIndex);
//    if (meshletIndex > 40) {
//        // for testing, only process first 40 meshlets
//        SetMeshOutputsEXT(0, 0);
//        return;
//    }
//
    // Read and unpack meshlet
    uvec4 packed = meshletDescs.packedMeshlets[meshletIndex];
    MeshletDesc meshlet = unpackMeshletDesc(packed);

    // test AABB:
    if (meshletIndex == 0) {
    vec3 min;
    vec3 max;
        //unpackAABB(meshlet.boundingBoxHigh, meshlet.boundingBoxLow, min, max);
        //debugPrintfEXT("MESH SHADER meshlet 0 aabb min %f %f %f max %f %f %f\n", meshlet.objectMin.x, meshlet.objectMin.y, meshlet.objectMin.z, meshlet.objectMax.x, meshlet.objectMax.y, meshlet.objectMax.z);
        vec3 sceneMin = model_ubo.boundingBox.min;
        vec3 sceneMax = model_ubo.boundingBox.max;
        uvec2 packedLowHigh;
        packedLowHigh.x = meshlet.boundingBoxLow;
        packedLowHigh.y = meshlet.boundingBoxHigh;
        vec3 outMin;
        vec3 outMax;
        unpackBoundingBox48_from_uvec2(packedLowHigh, sceneMin, sceneMax, outMin, outMax);
        //debugPrintfEXT("MESH SHADER unpacked aabb min %f %f %f max %f %f %f\n", outMin.x, outMin.y, outMin.z, outMax.x, outMax.y, outMax.z);
    }

    {
        // reconstruct meshlet AABB:
        vec3 sceneMin = model_ubo.boundingBox.min;
        vec3 sceneMax = model_ubo.boundingBox.max;
        uvec2 packedLowHigh;
        packedLowHigh.x = meshlet.boundingBoxLow;
        packedLowHigh.y = meshlet.boundingBoxHigh;
        vec3 outMin;
        vec3 outMax;
        unpackBoundingBox48_from_uvec2(packedLowHigh, sceneMin, sceneMax, outMin, outMax);

        // cull meshlet if outside view frustum:
        BoundingBox mbb;
        mbb.min = outMin;
        mbb.max = outMax;
        bool isOutside = isOutsideView(mbb, payload.mvp);
        if (meshletIndex > 0)debugPrintfEXT("MESH SHADER meshlet %d\n", meshletIndex);
        if (isOutside) {
            //debugPrintfEXT("MESH SHADER meshlet %d culled\n", meshletIndex);
            SetMeshOutputsEXT(0, 0);
            return;
        }
    }

    // Set meshlet output counts
    uint vertexCount = meshlet.numVertices;
    uint primCount = meshlet.numPrimitives;
    uint indexBufferOffset = meshlet.indexBufferOffset;
    // define subset of triangles to draw by setting primStart and primCount
    //primCount = 10;
    uint primStart = 0;
    primCount = primCount - primStart; // skip first 20 primitives for testing

    // sanity check
    if (vertexCount > GLEXT_MESHLET_VERTEX_COUNT || primCount > GLEXT_MESHLET_PRIMITIVE_COUNT) {
        //debugPrintfEXT("MESH SHADER ERROR: vertexCount %d or primCount %d exceeds limits\n", vertexCount, primCount);
        return;
    }
//    if (meshletIndex < 185 || meshletIndex > 185){
//        SetMeshOutputsEXT(0, 0);
//        return; // for testing, skip all but meshlet 1000
//    }
//
    SetMeshOutputsEXT(vertexCount, primCount);
    //debugPrintfEXT("MESH SHADER INFO: vertexCount %d primCount %d\n", vertexCount, primCount);

    // 1. Fetch meshlet-local to global vertex mapping
    uint use = 0;
    for (uint v = 0; v < vertexCount; ++v) {
        uint globalVertexIndex = globalIndexBuffer.index[indexBufferOffset + v];
        PBRVertex vert = vertices.vertex[globalVertexIndex];
        outVert[v].pad0 = 0.5;
        if (vert.color0.x == 0.42) {
            use = 1; // use this vertex for testing
        }
    }
    if (use == 0 && false) {
        return; // no vertices marked for use
    }
    for (uint v = 0; v < vertexCount; ++v) {
    //indexBufferOffset = 0;
        uint globalVertexIndex = globalIndexBuffer.index[indexBufferOffset + v];
        PBRVertex vert = vertices.vertex[globalVertexIndex];
        //debugPrintfEXT("MESH SHADER INFO: v global index %d iterator v %d value %d\n", indexBufferOffset + v, v, globalVertexIndex);
        //debugPrintfEXT("MESH SHADER marked vert %d: col %f pos %f %f %f UV %f %f\n", globalVertexIndex, vert.color0.x, vert.position.x, vert.position.y, vert.position.z, vert.uv0.x, vert.uv0.y);
        outVert[v].pad0 = 0.5;
        if (vert.color0.x == 0.63) {
            use = 1; // use this vertex for testing
            outVert[v].pad0 = 1.0;
            //vert.uv0.x = 0.0; // force uv0.x to 0.0 for testing
            //vert.uv0.y = 1.0; // force uv0.y to 1.0 for testing
            //debugPrintfEXT("MESH SHADER marked vert: col %f pos %f %f %f UV %f %f\n", vert.color0.x, vert.position.x, vert.position.y, vert.position.z, vert.uv0.x, vert.uv0.y);
        }
        //outVert[v].pos = vert.position;
        // Set more attributes as needed
        //if(v == 0) debugPrintfEXT("MESH SHADER globIndexBuffer %d pos %f %f %f\n", globalVertexIndex, vert.position.x, vert.position.y, vert.position.z);
        gl_MeshVerticesEXT[v].gl_Position = payload.mvp * vec4(vert.position, 1.0);
        outVert[v].color0 = vert.color0;

        if ((meshlet.vertexPack & 0x01) != 0) {
            // Bit 0 is set
            // apply debug colors
            vec3 debugColor = DEBUG_COLORS[meshletIndex % 256];
            outVert[v].color0 = vec4(debugColor, 1.0); // apply debug color to vertex color
            //debugPrintfEXT("MESH SHADER DEBUG COLORS\n");
        }

        outVert[v].uv0 = vert.uv0;
        outVert[v].uv1 = vert.uv1;
        //outVert[v].normal = vert.normal;
        outVert[v].weight0 = vert.weight0;
        outVertFlat[v].joint0 = vert.joint0;
//	    if (vert.uv0.y < 1.0) {
//		    debugPrintfEXT("PBR MESH in uv0 %f %f\n", vert.uv0.x, vert.uv0.y);
//	    }
//
        vec4 locPos;
	    locPos = model_ubo.model * vec4(vert.position, 1.0);
	    outVert[v].normal = normalize(transpose(inverse(mat3(model_ubo.model))) * vert.normal);
	    //locPos.y = -locPos.y;
	    outVert[v].worldPos = locPos.xyz / locPos.w;
        //debugPrintfEXT("loc.w %f\n", locPos.w);
//        if ((model_ubo.flags & MODEL_RENDER_FLAG_USE_VERTEX_COLORS) != 0) { // if model_ubo.flags & MODEL_FLAG_PRELIGHT_VERTICES
//        // bit 0 is set
//            gl_MeshVerticesEXT[v].gl_Position = vec4(0.0, 0.0, 0.0, 0.0); // W=0, will be clipped
//            debugPrintfEXT("MESH SHADER vert clipped, you idiot!\n");
//        } else {
//            gl_MeshVerticesEXT[v].gl_Position =  ubo.proj * ubo.view * vec4(outVert[v].worldPos, 1.0);
//        }
        gl_MeshVerticesEXT[v].gl_Position =  ubo.proj * ubo.view * vec4(outVert[v].worldPos, 1.0);
    }
        
//    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
//    gl_PrimitiveTriangleIndicesEXT[1] = uvec3(0, 3, 1);
//    gl_PrimitiveTriangleIndicesEXT[2] = uvec3(2, 1, 4);

    // 2. Emit triangles using local indices from primitiveIndexBuffer
    // Each triangle is 3 bytes (local indices into meshlet vertex array)
    //debugPrintfEXT("MESH SHADER INFO: vertexCount %d  primCount %d \n", vertexCount, primCount);
    for (uint p = primStart; p < primStart + primCount; ++p) {
        uint localPrimBufferIndex = indexBufferOffset * 3 + p * 3;
        //if (meshletIndex < 1 && p == 0) debugPrintfEXT("MESH SHADER localPrimBufferIndex %d\n", localPrimBufferIndex);
        // unpack prim index from uint to byte:
        uint byteValue0 = (primitiveIndexBuffer.primitiveIndices[localPrimBufferIndex / 4] >> ((localPrimBufferIndex % 4) * 8)) & 0xFFu;
        localPrimBufferIndex++;
        uint byteValue1 = (primitiveIndexBuffer.primitiveIndices[localPrimBufferIndex / 4] >> ((localPrimBufferIndex % 4) * 8)) & 0xFFu;
        localPrimBufferIndex++;
        uint byteValue2 = (primitiveIndexBuffer.primitiveIndices[localPrimBufferIndex / 4] >> ((localPrimBufferIndex % 4) * 8)) & 0xFFu;

        // Each primitive is 3 bytes packed into uints (4 per uint)
        //uint i0 = primitiveIndexBuffer.primitiveIndices[p] & 0xFFu;
        //uint i1 = primitiveIndexBuffer.primitiveIndices[p + 1] & 0xFFu;
        //uint i2 = primitiveIndexBuffer.primitiveIndices[p + 2] & 0xFFu;
        //if (meshletIndex < 1 && p < primCount)
        uint primIndex = localPrimBufferIndex / 4;
        //debugPrintfEXT("MESH SHADER uint index %d value %u\n", primIndex, primitiveIndexBuffer.primitiveIndices[primIndex]);
        //debugPrintfEXT("MESH SHADER uint index %d tri %d prim %d %d %d\n", primIndex, p, byteValue0, byteValue1, byteValue2);
        gl_PrimitiveTriangleIndicesEXT[p-primStart] = uvec3(byteValue0, byteValue1, byteValue2);
        //if (meshletIndex < 1 && p == 90) debugPrintfEXT("MESH SHADER X count %d prim %d %d %d\n", primCount, byteValue0, byteValue1, byteValue2);
    }

//    gl_MeshVerticesEXT[0].gl_Position = vec4(0.5,-0.5, 0, 1);
//    gl_MeshVerticesEXT[1].gl_Position = vec4(0.5, 0.5, 0, 1);
//    gl_MeshVerticesEXT[2].gl_Position = vec4(-0.5, 0.5, 0, 1);
//    gl_PrimitiveTriangleIndicesEXT[0] =  uvec3(0, 1, 2);
}

//layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
//layout(triangles, max_vertices = 3, max_primitives = 1) out;
//
//void main()
//{
//  //debugPrintfEXT("mesh shader main start\n");
//  uint vertexCount = 3;
//  uint triangleCount = 1;
//  SetMeshOutputsEXT(vertexCount, triangleCount);
//  gl_MeshVerticesEXT[0].gl_Position = vec4(0.5,-0.5, 0, 1);
//  gl_MeshVerticesEXT[1].gl_Position = vec4(0.5, 0.5, 0, 1);
//  gl_MeshVerticesEXT[2].gl_Position = vec4(-0.5, 0.5, 0, 1);
//  gl_PrimitiveTriangleIndicesEXT[0] =  uvec3(0, 1, 2);
//  //debugPrintfEXT("mesh shader main end\n");
//}
//