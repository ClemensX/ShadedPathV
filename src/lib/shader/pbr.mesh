#version 460
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_mesh_shader : enable
#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference_uvec2 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "common_cpp_shader.h"
#include "shadermaterial.glsl"
#include "pbr_mesh_common.glsl"
#include "debug_colors.glsl"

taskPayloadSharedEXT TaskPayload payload;

// Output: up to 256 vertices and 512 primitives per meshlet (adjust as needed)
layout(local_size_x = 1) in;
layout(max_vertices = GLEXT_MESHLET_VERTEX_COUNT, max_primitives = GLEXT_MESHLET_PRIMITIVE_COUNT) out;
layout(triangles) out;

layout(location = 0) out PBRVertexOutFlat outVertFlat[];
layout(location = 1) out PBRVertexOut outVert[];

GPUMeshIndexBuffer gpuIndices = GPUMeshIndexBuffer(pushConstants.meshStorageBufferAddress + 0);
GPUMeshInfoBuffer gpuInfos = GPUMeshInfoBuffer(pushConstants.baseAddressInfos);

uint meshIndex = model_ubo.meshNumber;
//uint meshIndex = 5;
MeshletDescs meshletDescs = MeshletDescs(pushConstants.meshStorageBufferAddress + gpuInfos.info[meshIndex].meshletOffset);
GlobalIndexBuffer globalIndexBuffer = GlobalIndexBuffer(pushConstants.meshStorageBufferAddress + gpuInfos.info[meshIndex].globalIndexOffset);
PrimitiveIndexBuffer primitiveIndexBuffer = PrimitiveIndexBuffer(pushConstants.meshStorageBufferAddress + gpuInfos.info[meshIndex].localIndexOffset);
VertexBuffer vertices = VertexBuffer(pushConstants.meshStorageBufferAddress + gpuInfos.info[meshIndex].vertexOffset);
/*
*/
/**///MeshletDescs meshletDescs = MeshletDescs(pushConstants.meshStorageBufferAddress + model_ubo.meshletOffset);
//GlobalIndexBuffer globalIndexBuffer = GlobalIndexBuffer(pushConstants.meshStorageBufferAddress + model_ubo.globalIndexOffset);
//PrimitiveIndexBuffer primitiveIndexBuffer = PrimitiveIndexBuffer(pushConstants.meshStorageBufferAddress + model_ubo.localIndexOffset);
//VertexBuffer vertices = VertexBuffer(pushConstants.meshStorageBufferAddress + model_ubo.vertexOffset);
/**/
void unpackAABB(uint pHigh, uint pLow, vec3 objectMin, vec3 objectMax) {
    debugPrintfEXT("uint64 aabb value: 0x %08x %08x\n", pHigh, pLow);
}

void check_inputs() {
    //uint maxPrim = gl_MaxMeshOutputPrimitivesEXT;
    //uint maxVert = gl_MaxMeshOutputVerticesEXT;
    uint meshletIndex = gl_WorkGroupID.x;
    if (meshletIndex != 185) return;
    uvec4 uv = meshletDescs.packedMeshlets[meshletIndex];
    //debugPrintfEXT("meshlet uvec4[0] %f %f %f %f\n", uv.x, uv.y, uv.z, uv.w);
    MeshletDesc meshlet = unpackMeshletDesc(uv);
    uint indexBufferOffset = meshlet.indexBufferOffset;
    //debugPrintfEXT("MESH SHADER meshlet index %d and indexBufferOffset %d\n", meshletIndex, indexBufferOffset);

    mat4 mvp = payload.mvp;
    //debugPrintfEXT("MESH SHADER mvp %f %f %f %f\n", mvp[0][0], mvp[1][1], mvp[2][2], mvp[3][3]);

    //debugPrintfEXT("MESH SHADER object render mode: flags == %d\n", model_ubo.flags);
    ShaderMaterial material = model_ubo.material;
    //debugPrintfEXT("mesh shader material workflow %f base set %d\n", material.workflow, material.baseColorTextureSet);
}

// Main mesh shader entry
void main()
{
    //check_inputs();

    //if (payload.meshletIndexX >= 100000)
    debugPrintfEXT("MESH SHADER: payload.meshletINdex: %u\n", payload.meshletIndexX);
    // check for culled objects:
    if (payload.meshletIndexX >= 100000 || payload.meshletIndexX == 0xFFFFFFFFu) {
        debugPrintfEXT("MESH SHADER: payload.meshletINdex: %u flags: %d ind2 %d \n", payload.meshletIndexX, payload.flags, payload.meshletIndex2);
        //debugPrintfEXT("MESH SHADER: object culled\n");
        SetMeshOutputsEXT(0, 0);
        return;
    }

    //debugPrintfEXT("MESH SHADER: object NOT culled\n");
    // Get meshlet index from task shader or workgroup
    uint meshletIndex = gl_WorkGroupID.x;
    meshletIndex = payload.meshletIndexX;
    //if (meshletIndex < 1) debugPrintfEXT("MESH SHADER meshletIndex %d\n", meshletIndex);
//    if (meshletIndex > 40) {
//        // for testing, only process first 40 meshlets
//        SetMeshOutputsEXT(0, 0);
//        return;
//    }
//
    // Read and unpack meshlet
    uvec4 packed = meshletDescs.packedMeshlets[meshletIndex];
    MeshletDesc meshlet = unpackMeshletDesc(packed);

    {
        // reconstruct meshlet AABB:
        vec3 sceneMin = model_ubo.boundingBox.min;
        vec3 sceneMax = model_ubo.boundingBox.max;
        uvec2 packedLowHigh;
        packedLowHigh.x = meshlet.boundingBoxLow;
        packedLowHigh.y = meshlet.boundingBoxHigh;
        vec3 outMin;
        vec3 outMax;
        unpackBoundingBox48_from_uvec2(packedLowHigh, sceneMin, sceneMax, outMin, outMax);

        // cull meshlet if outside view frustum:
        BoundingBox mbb;
        mbb.min = outMin;
        mbb.max = outMax;
        bool isOutside = isOutsideView(mbb, payload.mvp);
        //if (meshletIndex > 0)debugPrintfEXT("MESH SHADER meshlet %d\n", meshletIndex);
        if (isOutside) {
            //debugPrintfEXT("MESH SHADER meshlet %d culled\n", meshletIndex);
            SetMeshOutputsEXT(0, 0);
            return;
        }
    }

    // Set meshlet output counts
    uint vertexCount = meshlet.numVertices;
    uint primCount = meshlet.numPrimitives;
    uint indexBufferOffset = meshlet.indexBufferOffset;
    // define subset of triangles to draw by setting primStart and primCount
    //primCount = 10;
    uint primStart = 0;
    primCount = primCount - primStart; // skip first 20 primitives for testing

    // sanity check
    if (vertexCount > GLEXT_MESHLET_VERTEX_COUNT || primCount > GLEXT_MESHLET_PRIMITIVE_COUNT) {
        //debugPrintfEXT("MESH SHADER ERROR: vertexCount %d or primCount %d exceeds limits\n", vertexCount, primCount);
        return;
    }
    SetMeshOutputsEXT(vertexCount, primCount);
    //debugPrintfEXT("MESH SHADER INFO: vertexCount %d primCount %d\n", vertexCount, primCount);

    // 1. Fetch meshlet-local to global vertex mapping
    uint use = 0;
    for (uint v = 0; v < vertexCount; ++v) {
        uint globalVertexIndex = globalIndexBuffer.index[indexBufferOffset + v];
        PBRVertex vert = vertices.vertex[globalVertexIndex];
        outVert[v].pad0 = 0.5;
        if (vert.color0.x == 0.42) {
            use = 1; // use this vertex for testing
        }
    }
    if (use == 0 && false) {
        return; // no vertices marked for use
    }
    for (uint v = 0; v < vertexCount; ++v) {
    //indexBufferOffset = 0;
        uint globalVertexIndex = globalIndexBuffer.index[indexBufferOffset + v];
        PBRVertex vert = vertices.vertex[globalVertexIndex];
        gl_MeshVerticesEXT[v].gl_Position = payload.mvp * vec4(vert.position, 1.0);
        outVert[v].color0 = vert.color0;

        outVert[v].uv0 = vert.uv0;
        outVert[v].uv1 = vert.uv1;
        //outVert[v].normal = vert.normal;
        outVert[v].weight0 = vert.weight0;
        outVertFlat[v].joint0 = vert.joint0;
//	    if (vert.uv0.y < 1.0) {
//		    debugPrintfEXT("PBR MESH in uv0 %f %f\n", vert.uv0.x, vert.uv0.y);
//	    }
//
        vec4 locPos;
	    locPos = model_ubo.model * vec4(vert.position, 1.0);
	    outVert[v].normal = normalize(transpose(inverse(mat3(model_ubo.model))) * vert.normal);
	    //locPos.y = -locPos.y;
	    outVert[v].worldPos = locPos.xyz / locPos.w;
        //debugPrintfEXT("loc.w %f\n", locPos.w);
        if ((model_ubo.flags & MODEL_RENDER_FLAG_USE_VERTEX_COLORS) != 0) { // if model_ubo.flags & MODEL_FLAG_PRELIGHT_VERTICES
            // apply debug colors
            vec3 debugColor = DEBUG_COLORS[meshletIndex % 256];
            outVert[v].color0 = vec4(debugColor, 1.0); // apply debug color to vertex color
        }
        gl_MeshVerticesEXT[v].gl_Position =  ubo.proj * ubo.view * vec4(outVert[v].worldPos, 1.0);
    }
        

    // 2. Emit triangles using local indices from primitiveIndexBuffer
    // Each triangle is 3 bytes (local indices into meshlet vertex array)
    //debugPrintfEXT("MESH SHADER INFO: vertexCount %d  primCount %d \n", vertexCount, primCount);
    for (uint p = primStart; p < primStart + primCount; ++p) {
        uint localPrimBufferIndex = indexBufferOffset * 3 + p * 3;
        //if (meshletIndex < 1 && p == 0) debugPrintfEXT("MESH SHADER localPrimBufferIndex %d\n", localPrimBufferIndex);
        // unpack prim index from uint to byte:
        uint byteValue0 = (primitiveIndexBuffer.primitiveIndices[localPrimBufferIndex / 4] >> ((localPrimBufferIndex % 4) * 8)) & 0xFFu;
        localPrimBufferIndex++;
        uint byteValue1 = (primitiveIndexBuffer.primitiveIndices[localPrimBufferIndex / 4] >> ((localPrimBufferIndex % 4) * 8)) & 0xFFu;
        localPrimBufferIndex++;
        uint byteValue2 = (primitiveIndexBuffer.primitiveIndices[localPrimBufferIndex / 4] >> ((localPrimBufferIndex % 4) * 8)) & 0xFFu;

        // Each primitive is 3 bytes packed into uints (4 per uint)
        //uint i0 = primitiveIndexBuffer.primitiveIndices[p] & 0xFFu;
        //uint i1 = primitiveIndexBuffer.primitiveIndices[p + 1] & 0xFFu;
        //uint i2 = primitiveIndexBuffer.primitiveIndices[p + 2] & 0xFFu;
        //if (meshletIndex < 1 && p < primCount)
        uint primIndex = localPrimBufferIndex / 4;
        //debugPrintfEXT("MESH SHADER uint index %d value %u\n", primIndex, primitiveIndexBuffer.primitiveIndices[primIndex]);
        //debugPrintfEXT("MESH SHADER uint index %d tri %d prim %d %d %d\n", primIndex, p, byteValue0, byteValue1, byteValue2);
        gl_PrimitiveTriangleIndicesEXT[p-primStart] = uvec3(byteValue0, byteValue1, byteValue2);
        //if (meshletIndex < 1 && p == 90) debugPrintfEXT("MESH SHADER X count %d prim %d %d %d\n", primCount, byteValue0, byteValue1, byteValue2);
    }

}
